
==================== FINAL INTERFACE ====================
2016-09-27 02:20:19.144922 UTC

interface hw0wa_KegkDhabp4x2nedVbV5lhB:Hw0 7103
  interface hash: 973ab6302a234b13d1fa52f1ba880296
  ABI hash: 6ed88f2480380559e7bae6f876425b58
  export-list hash: 406a08375118d8ec29b300dc5c48589b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 2cd49d211df5794359041f95a6412f44
  sig of: Nothing
  used TH splices: False
  where
exports:
  Hw0.add
  Hw0.additivePersistence
  Hw0.bigAdd
  Hw0.bigMul
  Hw0.clone
  Hw0.digitalRoot
  Hw0.digits
  Hw0.digitsOfInt
  Hw0.foldLeft
  Hw0.intString
  Hw0.listReverse
  Hw0.mulByDigit
  Hw0.mult
  Hw0.padZero
  Hw0.palindrome
  Hw0.pipe
  Hw0.removeZero
  Hw0.sepConcat
  Hw0.sqSum
  Hw0.stringOfList
  Hw0.sumInt
  Hw0.sumList
  Hw0.BigInt
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
6da8be75a81df39d4ad87da2427059cc
  $wadd ::
    Hw0.BigInt
    -> Hw0.BigInt -> GHC.Types.Int -> Hw0.BigInt -> Hw0.BigInt
  {- Arity: 4, Strictness: <S,1*U><S,1*U><L,U(U)><L,U>,
     Inline: [0] -}
6b118e048c70a1dc5eef46d610bc0078
  $wadditivePersistence :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
4efc1e41d4a9c39d99f62862c8ce6633
  $wclone :: a -> GHC.Prim.Int# -> [a]
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
6228b913024fd2702956e2d0c155c314
  $wdigitalRoot :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
d3ab577ca0865e1d43e9427a05737ca9
  $wdigitsOfInt :: GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
ab56c330be59e343751f4a192d67a84f
  $wgo :: [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
a3ce2118ddbf851687ccd3e580d035d2
  $wmulByDigit :: GHC.Prim.Int# -> Hw0.BigInt -> Hw0.BigInt
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: Hw0.BigInt ->
                 case ww of ds {
                   DEFAULT
                   -> case Hw0.$wmult
                             (Hw0.listReverse @ GHC.Types.Int w)
                             (GHC.Types.I# ds)
                             Hw0.bigAdd1
                             (GHC.Types.[] @ GHC.Types.Int) of ww1 { (#,#) ww2 ww3 ->
                      Hw0.removeZero (GHC.Types.: @ GHC.Types.Int ww2 ww3) }
                   0 -> Hw0.bigMul1
                   1 -> w }) -}
b2b759b807fd9543f6328a5fa58a2843
  $wmult ::
    Hw0.BigInt
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> Hw0.BigInt
    -> (# GHC.Types.Int, [GHC.Types.Int] #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,U(U)><L,U(U)><L,U>, Inline: [0] -}
f22581a651c8eb4d0e7aee9f556b9eda
  $wpadZero ::
    Hw0.BigInt -> Hw0.BigInt -> (# Hw0.BigInt, Hw0.BigInt #)
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0],
     Unfolding: (\ w :: Hw0.BigInt w1 :: Hw0.BigInt ->
                 case GHC.List.$wlenAcc @ GHC.Types.Int w 0 of ww2 { DEFAULT ->
                 case GHC.List.$wlenAcc @ GHC.Types.Int w1 0 of ww1 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww2 ww1) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<# ww2 ww1) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# ww2 ww1) of wild2 {
                             GHC.Types.False
                             -> case Hw0.bigAdd2 ret_ty (# Hw0.BigInt, Hw0.BigInt #) of {}
                             GHC.Types.True -> (# w, w1 #) }
                        GHC.Types.True
                        -> (# GHC.Base.++
                                @ GHC.Types.Int
                                (Hw0.$wclone @ GHC.Types.Int Hw0.bigAdd1 (GHC.Prim.-# ww1 ww2))
                                w,
                              w1 #) }
                   GHC.Types.True
                   -> (# w,
                         GHC.Base.++
                           @ GHC.Types.Int
                           (Hw0.$wclone @ GHC.Types.Int Hw0.bigAdd1 (GHC.Prim.-# ww2 ww1))
                           w1 #) } } }) -}
192b68055e651873c2d2ed7ac6e46678
  $wsumInt :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
2f7eb3f35f1dc2ef4eacb684d444f5a0
  $wsumList :: [GHC.Types.Int] -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
848b8505373efd4724fb5b36f3a4b320
  type BigInt = [GHC.Types.Int]
e89b924a0734bb041cae305c9f8f5570
  add ::
    (Hw0.BigInt, Hw0.BigInt)
    -> GHC.Types.Int -> Hw0.BigInt -> Hw0.BigInt
  {- Arity: 3, Strictness: <S(SS),1*U(1*U,1*U)><L,U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: (Hw0.BigInt, Hw0.BigInt)
                   w1 :: GHC.Types.Int
                   w2 :: Hw0.BigInt ->
                 case w of ww { (,) ww1 ww2 -> Hw0.$wadd ww1 ww2 w1 w2 }) -}
9a1764c84be657e27bf909b61cd5a97b
  additivePersistence :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,U(U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case Hw0.$wadditivePersistence ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
5f8d57b46914b558f0a07d4c9e7a9d4a
  bigAdd :: Hw0.BigInt -> Hw0.BigInt -> Hw0.BigInt
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ l1 :: Hw0.BigInt l2 :: Hw0.BigInt ->
                 case Hw0.$wpadZero l1 l2 of ww { (#,#) ww1 ww2 ->
                 Hw0.$wadd
                   (Hw0.listReverse @ GHC.Types.Int ww1)
                   (Hw0.listReverse @ GHC.Types.Int ww2)
                   Hw0.bigAdd1
                   (GHC.Types.[] @ GHC.Types.Int) }) -}
44d2561e460e1d00899bdb427c5bbfd6
  bigAdd1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
fba89b6bfbb6358cb0c6e0399c986677
  bigAdd2 :: (Hw0.BigInt, Hw0.BigInt)
  {- Strictness: b -}
d42596cf4d1de4c629fec7762f2a3ad6
  bigMul :: Hw0.BigInt -> Hw0.BigInt -> Hw0.BigInt
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ l1 :: Hw0.BigInt l2 :: Hw0.BigInt ->
                 letrec {
                   $wgo1 :: [GHC.Types.Int]
                            -> [GHC.Types.Int]
                            -> Hw0.BigInt
                            -> (# [GHC.Types.Int], Hw0.BigInt #)
                     {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [0] -}
                   = \ w :: [GHC.Types.Int] ww :: [GHC.Types.Int] ww1 :: Hw0.BigInt ->
                     case w of wild {
                       [] -> (# ww, ww1 #)
                       : y ys
                       -> $wgo1
                            ys
                            (GHC.Base.++ @ GHC.Types.Int ww Hw0.bigMul1)
                            (case y of ww2 { GHC.Types.I# ww3 ->
                             Hw0.bigAdd
                               ww1
                               (GHC.Base.++ @ GHC.Types.Int (Hw0.$wmulByDigit ww3 l2) ww) }) }
                 } in
                 case $wgo1
                        (Hw0.listReverse @ GHC.Types.Int l1)
                        (GHC.Types.[] @ GHC.Types.Int)
                        (GHC.Types.[] @ GHC.Types.Int) of ww { (#,#) ww1 ww2 ->
                 ww2 }) -}
dc21edc0b841a0d8c3ed0d1c90bada59
  bigMul1 :: [GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Int
                   Hw0.bigAdd1
                   (GHC.Types.[] @ GHC.Types.Int)) -}
303e21876f5c7a7c0128668b43a09abe
  clone :: a -> GHC.Types.Int -> [a]
  {- Arity: 2, Strictness: <L,U><S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a w :: a w1 :: GHC.Types.Int ->
                 case w1 of ww { GHC.Types.I# ww1 -> Hw0.$wclone @ a w ww1 }) -}
ab8a967ee91014f72e175a4662d853ca
  digitalRoot :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case Hw0.$wdigitalRoot ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
ad3f0bd7666fd6a344f61cfc1d2b9b4d
  digits :: GHC.Types.Int -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ n :: GHC.Types.Int ->
                 Hw0.digitsOfInt (GHC.Num.$fNumInt_$cabs n)) -}
957910f870046da3d95181d33cdea81c
  digitsOfInt :: GHC.Types.Int -> [GHC.Types.Int]
  {- Arity: 1, Strictness: <S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 -> Hw0.$wdigitsOfInt ww1 }) -}
c1a6a43cca2a4eb6c9fa54ad68d948b1
  foldLeft :: (a -> b -> a) -> a -> [b] -> a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> GHC.List.foldl' @ b @ a) -}
87fd747f425504d87d51e8b614e93532
  intString :: GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m2,
     Unfolding: InlineRule (0, True, True) GHC.Show.$fShowInt_$cshow -}
a6725b3db3d1cdd96595287d11744ba3
  listReverse :: [a] -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
bc628aedb76aa30d98b14e4e6d5547ed
  mulByDigit :: GHC.Types.Int -> Hw0.BigInt -> Hw0.BigInt
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><L,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Hw0.BigInt ->
                 case w of ww { GHC.Types.I# ww1 -> Hw0.$wmulByDigit ww1 w1 }) -}
b8ad61f96a95d3956a3b0ac8ee892a6a
  mult ::
    Hw0.BigInt
    -> GHC.Types.Int -> GHC.Types.Int -> Hw0.BigInt -> Hw0.BigInt
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,U(U)><L,U(U)><L,U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ w :: Hw0.BigInt
                   w1 :: GHC.Types.Int
                   w2 :: GHC.Types.Int
                   w3 :: Hw0.BigInt ->
                 case Hw0.$wmult w w1 w2 w3 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ GHC.Types.Int ww1 ww2 }) -}
5e9866c8eefb354cfb990ce0323f6d14
  padZero :: Hw0.BigInt -> Hw0.BigInt -> (Hw0.BigInt, Hw0.BigInt)
  {- Arity: 2, Strictness: <S,U><S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Hw0.BigInt w1 :: Hw0.BigInt ->
                 case Hw0.$wpadZero w w1 of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
e03b00dd4880b1f1b77abb725f73847e
  palindrome :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Base.String ->
                 GHC.Base.eqString w (Hw0.listReverse @ GHC.Types.Char w)) -}
de3e3be723c1c7205b4fc1107c934d76
  pipe :: [a -> a] -> a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a fs :: [a -> a] ->
                 Hw0.pipe2 @ a fs (Hw0.pipe1 @ a)) -}
e643d6711f68e27cfae0328232819eba
  pipe1 :: a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ @ a x :: a -> x) -}
7244e4d040b48a0ed700d149c6b57f89
  pipe2 :: [a -> a] -> (a -> a) -> a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
5e7371e8a6dab8dfe240e81f2ad10e43
  removeZero :: Hw0.BigInt -> Hw0.BigInt
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
62716096df630837a6d1d679643c1cb7
  sepConcat ::
    GHC.Base.String -> [GHC.Base.String] -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ sep :: GHC.Base.String ds :: [GHC.Base.String] ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : h t
                   -> letrec {
                        go :: [[GHC.Types.Char]] -> GHC.Base.String -> GHC.Base.String
                          {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                        = \ ds1 :: [[GHC.Types.Char]] eta :: GHC.Base.String ->
                          case ds1 of wild1 {
                            [] -> eta
                            : y ys
                            -> go
                                 ys
                                 (GHC.Base.++
                                    @ GHC.Types.Char
                                    eta
                                    (GHC.Base.++ @ GHC.Types.Char sep y)) }
                      } in
                      go t h }) -}
441d4c32213615db449fc55771e306c1
  sqSum :: [GHC.Types.Int] -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Types.Int] ->
                 case Hw0.$wgo w 0 of ww { DEFAULT -> GHC.Types.I# ww }) -}
fa0784604d8645c07d8b7878cc6ec81e
  stringOfList :: (a -> GHC.Base.String) -> [a] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,C(U)><L,1*U>,
     Unfolding: (\ @ a f :: a -> GHC.Base.String xs :: [a] ->
                 GHC.CString.unpackAppendCString#
                   "["#
                   (GHC.Base.++
                      @ GHC.Types.Char
                      (Hw0.sepConcat
                         Hw0.stringOfList2
                         (GHC.Base.map @ a @ [GHC.Types.Char] f xs))
                      Hw0.stringOfList1)) -}
8102933aab3d40c9221edeeda61be2f2
  stringOfList1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "]"#) -}
c4283927951d87afed4e0f8fc8159066
  stringOfList2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
1798defa05e50b71bf50f473d4907e27
  sumInt :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U(U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case Hw0.$wsumInt ww1 of ww2 { DEFAULT -> GHC.Types.I# ww2 } }) -}
e7af2e9cbcaf8d55f70ac3b909ad0ee7
  sumList :: [GHC.Types.Int] -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Types.Int] ->
                 case Hw0.$wsumList w of ww { DEFAULT -> GHC.Types.I# ww }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

